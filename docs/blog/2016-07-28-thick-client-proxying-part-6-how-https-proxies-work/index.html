<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
    
    
      <link href="/css/fonts.css" rel="stylesheet" type="text/css">
    
  

  
  <title>Thick Client Proxying - Part 6: How HTTP(s) Proxies Work</title>

  
  
  <link rel="stylesheet" href="/css/hugo-octopress.css">

  
  

  
    <link rel="stylesheet" href="/css/fork-awesome.min.css">
  

  
  <link href="http://localhost:1313/favicon.png" rel="icon">

  
  

  <meta name="description" content="" />
  <meta name="keywords" content="[Parsia Hakimian Parsiya infosec information security]">
  <meta name="author" content="Parsia">

  
  <meta name="generator" content="Hugo 0.83.1" />

  
  

  
  
    

  
    <meta name="twitter:card" content="summary"/>
  
  
  <meta name="twitter:title" content="Thick Client Proxying - Part 6: How HTTP(s) Proxies Work"/>
  <meta name="twitter:description" content="In order to create our own custom proxies, first we need to know how proxies work. When I wanted to write a custom proxy tool (it&#39;s a simple Python script) in Hipchat part3, I had to go back and learn how they work. I did not find such a resource online that looked at proxies from an infosec perspective. Most talked about how to configure caching or forwarding proxies and not much about MitM ones. I have briefly talked about it in the section 2 of the same post named How does a Proxy Work?. In this post I am going to take a deep(er) dive. I actually read some RFCs and they were surprisingly well written.

If you want to skip the intro, go to section 3."/>
  
  <meta name="twitter:domain" content="parsiya.net"/>
  <meta name="twitter:creator" content="@CryptoGangsta"/>

  

  
  



</head>
<body>


<header role="banner">
<hgroup>
  
  <h1><a href="http://localhost:1313/">அஃக</a></h1>
    <h2>தமிழின் பெரிய சொற்தொகுப்பு</h2>
</hgroup></header>


<nav role="navigation">
<fieldset class="mobile-nav">
  
  <select onchange="location = this.value;">
    <option value="">Navigate…</option>
      
        <option value="http://localhost:1313/about/">» About Me!</option>
      
        <option value="http://localhost:1313/letters/">» எழுத்து</option>
      
  </select>
</fieldset>


<ul class="main-navigation">
  
  
    
      <li><a href="http://localhost:1313/about/" title="About Me!"  target="_blank"  rel="noopener noreferrer">About Me!</a></li>
    
  
    
      <li><a href="http://localhost:1313/letters/" title="எழுத்து"  target="_blank"  rel="noopener noreferrer">எழுத்து</a></li>
    
  
</ul>

<ul class="subscription">
  
    
        <a href="http://localhost:1313/index.xml" target="_blank" type="application/rss+xml" title="RSS" rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a>
    
  
</ul>


  <form action="https://www.google.com/search" method="get" target="_blank" rel="noopener noreferrer">
    <fieldset role="search">
      <input class="search" type="text" name="q" results="0" placeholder="Search"/>
      <input type="hidden" name="q" value="site:http://localhost:1313/" />
    </fieldset>
  </form>

</nav>


<div id="main">
  <div id="content">
    <div>
      <article class="hentry" role="article">

        
        

<header>
  <p class="meta">Jul 28, 2016
     - 14 minute read 
     - <a href="http://localhost:1313/blog/2016-07-28-thick-client-proxying-part-6-how-https-proxies-work/#disqus_thread">Comments</a>

    
    
      - <a class="label" href="http://localhost:1313/categories/thick-client-proxying/">Thick Client Proxying </a><a class="label" href="http://localhost:1313/categories/proxy/">Proxy </a>
    
  </p>
  <h1 class="entry-title">
     Thick Client Proxying - Part 6: How HTTP(s) Proxies Work 
  </h1>
</header>


        <div class="entry-content">
          
          
          
            <nav id="TableOfContents">
<ul>
<li><a href="#0-why-do-i-need-to-know-how-proxies-work">0. Why do I Need to Know How Proxies Work?</a></li>
<li><a href="#1-become-one-with-the-proxy">1. Become One with the Proxy</a>
<ul>
<li><a href="#1-1-what-does-it-mean">1.1. What does it Mean?</a></li>
</ul></li>
<li><a href="#2-brief-intro-to-two-types-of-proxies">2. Brief Intro to Two Types of Proxies</a>
<ul>
<li><a href="#2-1-forwarding-proxies">2.1. Forwarding Proxies</a></li>
<li><a href="#2-2-tls-terminating-proxies">2.2. TLS Terminating Proxies</a>
<ul>
<li><a href="#2-2-1-it-s-not-always-tls">2.2.1. It's not Always TLS</a></li>
</ul></li>
</ul></li>
<li><a href="#section-3">3. How HTTP(s) Proxies work</a>
<ul>
<li><a href="#3-1-http-proxy">3.1. HTTP Proxy</a>
<ul>
<li><a href="#3-1-1-why-not-use-the-host-header">3.1.1. Why not Use the Host Header?</a></li>
</ul></li>
<li><a href="#3-2-forwarding-proxy-and-https">3.2. Forwarding Proxy and HTTPs</a>
<ul>
<li><a href="#3-2-1-the-connect-request">3.2.1. The CONNECT Request</a></li>
</ul></li>
<li><a href="#3-3-burp-and-https">3.3. Burp and HTTPs</a>
<ul>
<li><a href="#3-3-1-correction-july-30th-2016">3.3.1. Correction - July 30th 2016</a></li>
<li><a href="#3-3-1-burp-s-invisible-mode">3.3.1. Burp's Invisible Mode</a></li>
</ul></li>
</ul></li>
<li><a href="#4-cloudfront-and-server-name-indication">4. Cloudfront and Server Name Indication</a></li>
<li><a href="#5-proxy-aware-clients">5. Proxy-Aware Clients</a></li>
<li><a href="#6-conclusion-and-future-plans">6. Conclusion and Future Plans</a></li>
</ul>
</nav>
          
          <p>In order to create our own custom proxies, first we need to know how proxies work. When I wanted to write a custom proxy tool (it's a simple Python script) in <a href="http://localhost:1313/blog/2015-10-19-proxying-hipchat-part-3-ssl-added-and-removed-here/" title="Proxying Hipchat Part 3: SSL Added and Removed Here" rel="nofollow" target="_blank">Hipchat part3</a>, I had to go back and learn how they work. I did not find such a resource online that looked at proxies from an infosec perspective. Most talked about how to configure caching or forwarding proxies and not much about MitM ones. I have briefly talked about it in the section 2 of the same post named <code>How does a Proxy Work?</code>. In this post I am going to take a deep(er) dive. I actually read some RFCs and they were surprisingly well written.</p>

<p>If you want to skip the intro, go to <a href="#section-3" title="How HTTP Proxies Work" rel="nofollow" target="_blank">section 3</a>.</p>

<h1 id="0-why-do-i-need-to-know-how-proxies-work">0. Why do I Need to Know How Proxies Work?</h1>

<p>That is a fair question. Most of the time, we pipe the browser to Burp and it works out of the box. However, if something small changes we will go into panic mode. What if the webapp uses a Java or Silverlight component and it has some quirky things? Another reason is for proxying thick clients because Burp as you have seen here is not just for webapps. My opinion is &quot;<strong>if the application uses HTTP, you can Burp it</strong>.&quot; Thick clients may not work out of the box when proxied (often just redirecting their traffic to the proxy is a pain). If we do not know how proxies work internally, we cannot troubleshoot the issues.</p>

<p>You are now convinced that you need to read this right? <strong>riiiiiiiiiiiiight?</strong></p>

<h1 id="1-become-one-with-the-proxy">1. Become One with the Proxy</h1>

<p>It really helps to put ourselves in place of the proxy when reading this. At least that is what worked for me. Proxy does not know whatever happens in the system like an observer. As an observer we can just make decisions about what the proxy <em>should</em> do. Things like &quot;the user typed google.com in their browser so the proxy must send the request to google.com.&quot; Well, how does the proxy know that? The proxy cannot magically see the browser's address bar.</p>

<h2 id="1-1-what-does-it-mean">1.1. What does it Mean?</h2>

<p>We are the proxy. The only things we see are the requests/packets that the client (e.g. browser) and the endpoint send to us. We do not know anything else. And as a proxy we must decide what to do with the requests that we receive with only our knowledge.</p>

<p>Now that we are hopefully in the zone, let's start.</p>

<h1 id="2-brief-intro-to-two-types-of-proxies">2. Brief Intro to Two Types of Proxies</h1>

<p>I am going to talk about two types of proxies here.</p>

<ul>
<li>Forwarding proxies</li>
<li>TLS terminating proxies</li>
</ul>

<p>The descriptions are not entirely accurate or detailed but are enough for our purpose. Of course this is not an exhaustive list. There are other proxies out there but these are the ones that we are interested in. To be honest we are only interested in TLS terminating proxies.</p>

<h2 id="2-1-forwarding-proxies">2.1. Forwarding Proxies</h2>

<p>We have all seen them before. These are corporate proxies that we see and use everyday. If you are in a corporate environment, check the proxy auto-config (pac) scripts. Essentially it's a text file that tells the application where to send the traffic and re-routes the traffic based on the endpoint. Usually if the endpoint is internal, things get routed normally through the internal network otherwise (requests sent over the internet) requests are sent to a forwarding proxy. You can see some examples at <a href="https://technet.microsoft.com/en-us/library/cc985335.aspx" rel="nofollow" target="_blank">Microsoft Technet</a>. From the point of view of the application,  the forwarding proxy is sitting between the internal network and the internet.</p>

<p>Based on the name, these proxies just forward packets and cannot look inside encrypted payloads (e.g. TLS). From the point of view of a typical forwarding proxy, an established TLS connection is just a bunch of packets with random looking TCP payloads.</p>

<h2 id="2-2-tls-terminating-proxies">2.2. TLS Terminating Proxies</h2>

<p>Burp is the prime example of this type. If you know what Burp does (and you probably do because you are reading this), you know what a TLS terminating proxy does. These are proxies that usually MitM the connections and unwrap TLS to look inside the payloads.</p>

<p>They could be applications like Burp or Fiddler which are usually used for (security) testing. Or could be appliances like Bluecoat or the <a href="https://live.paloaltonetworks.com/t5/Configuration-Articles/How-to-Implement-and-Test-SSL-Decryption/ta-p/59719" rel="nofollow" target="_blank">SSL decryption module</a> of Palo Alto Networks' &quot;thing&quot; (whatever it is named). Usually these appliances are used for deep packet inspection.</p>

<p>You could make Burp work like a forwarding proxy by adding all endpoints to Burp's <a href="http://localhost:1313/blog/2016-03-27-thick-client-proxying-part-1-burp-interception-and-proxy-listeners/#1-4-ssl-pass-through" title="SSL Pass Through" rel="nofollow" target="_blank">SSL Pass Through</a>. This is useful for troubleshooting connections.</p>

<h3 id="2-2-1-it-s-not-always-tls">2.2.1. It's not Always TLS</h3>

<p>True. Sometimes our proxy decrypts (or decodes) layers of non-TLS encryption (or encoding). I am classifying all of these proxies under this category because TLS has become the most common way of protecting data in transit.</p>

<h1 id="section-3">3. How HTTP(s) Proxies work</h1>

<p>Now we get to the main part. In all examples we have a browser that uses a proxy (via some proxy settings) and the browser knows that it is connected to a proxy (I will talk about this later).</p>

<h2 id="3-1-http-proxy">3.1. HTTP Proxy</h2>

<p>In this case the browser is using plain HTTP (meaning there's no TLS). Both forwarding and TLS terminating proxies work similarly in this case.</p>

<p>Let's assume we have typed <a href="http://www.yahoo.com" rel="nofollow" target="_blank">http://www.yahoo.com</a> in the browser. Let's forget that we get a 302 redirect in the real world and assume yahoo.com is available over HTTP. I probably should have used example.com instead but I am lazy and don't want to create the diagrams again.</p>

<p>The browser establishes a TCP connection to the proxy (the famous <code>SYN-SYNACK-ACK</code>) and then sends the GET request.</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/01.png" title="What does the proxy see?" alt="What does the proxy see?">
  <span class="caption-text">What does the proxy see?</span>
</span>


<p>Here's how the GET request looks like in Wireshark (we can see it in plaintext because there's no TLS).</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/02.png" title="GET request sent to the proxy" alt="GET request sent to the proxy">
  <span class="caption-text">GET request sent to the proxy</span>
</span>


<p>Now, we (proxy) must decide where to send this GET request. Note that both the proxy (Burp) and the browser are on the same machine so the source and destination IP addresses in the previous picture are both <code>127.0.0.1</code>. So we cannot forward the request based on the destination IP address.</p>

<p>How is this GET request different from a non-proxied GET request? I disabled my browser's proxy settings and recaptured the same GET request.</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/03.png" title="GET request without using a proxy" alt="GET request without using a proxy">
  <span class="caption-text">GET request without using a proxy</span>
</span>


<p>Check the highlighted parts. The request sent to proxy has the <code>absoluteURI</code>. In simple words it has the complete URI (or URL) in the GET request. The proxy uses this to discover the endpoint. This was initially discussed in RFC2616 which discusses HTTP/1.1. In <a href="https://tools.ietf.org/html/rfc2616#section-5.1.2" rel="nofollow" target="_blank">section 5.1.2. Request-URI</a>, we see:</p>

<blockquote>
<p>The absoluteURI form is REQUIRED when the request is being made to a proxy.<br />
...<br />
An example Request-Line would be:<br />
GET <a href="http://www.w3.org/pub/WWW/TheProject.html" rel="nofollow" target="_blank">http://www.w3.org/pub/WWW/TheProject.html</a> HTTP/1.1</p>
</blockquote>

<p>In newer RFCs you can look it up using <code>absolute-URI</code>. This format is called <code>absolute-form</code>. In <a href="https://tools.ietf.org/html/rfc7230" rel="nofollow" target="_blank">RFC7230 - HTTP/1.1: Message Syntax and Routing</a> we can check <a href="https://tools.ietf.org/html/rfc7230#section-5.3.2" rel="nofollow" target="_blank">section 5.3.2. absolute-form</a> to see:</p>

<blockquote>
<p>When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in absolute-form as the request-target.</p>

<p>absolute-form  = absolute-URI</p>
</blockquote>

<p>Note that the RFC instructs clients to send the <code>absolute-URI</code> no matter what (even if they are using a <code>CONNECT</code> request) as we will see shortly.</p>

<p>The proxy uses this <code>absolute-URI</code> to forward the request to the endpoint (in this case Yahoo!). Both forwarding and TLS terminating proxies work similarly in this case because they both can look inside HTTP payloads.</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/04.png" title="HTTP proxy in action" alt="HTTP proxy in action">
  <span class="caption-text">HTTP proxy in action</span>
</span>


<ol>
<li>Browser establishes a TCP connection to proxy.</li>
<li>Browser sends the HTTP request (with an absolute-URI) to proxy.</li>
<li>Proxy establishes a TCP connection to yahoo.com (using the absolute-URI).</li>
<li>Proxy forwards the HTTP request.</li>
<li>Proxy receives the response.</li>
<li>Proxy closes the connection to yahoo.com.</li>
<li>Proxy forwards the response to browser.</li>
<li>Proxy signals to close the connection (using FIN).</li>
<li>Connection between browser and Proxy is closed.</li>
</ol>

<h3 id="3-1-1-why-not-use-the-host-header">3.1.1. Why not Use the Host Header?</h3>

<p>If you have done at least a bit of HTTP security testing (or have seen some HTTP requests), you are probably asking &quot;why not just use the Host header?&quot; That is a very good question and it was mine too. We are the proxy and we see the <code>Host</code> header, why do we need to use the absolute-URI instead?</p>

<p>The answer is backward compatibility with HTTP/1.0 proxies. This is hinted in <a href="https://tools.ietf.org/html/rfc7230#section-5.4" rel="nofollow" target="_blank">section 5.4. Host</a> of RFC7230:</p>

<blockquote>
<p>A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.</p>
</blockquote>

<p>Later it instructs proxies to rely on the absolute-URI and ignore the <code>Host</code> header. If the <code>Host</code> header is different from the URI, then the proxy must generate the correct header and send it with the request.</p>

<h2 id="3-2-forwarding-proxy-and-https">3.2. Forwarding Proxy and HTTPs</h2>

<p>But what about HTTP(s) forwarding proxies? How do they work?</p>

<p>Again let's put ourselves in place of the forwarding proxy. We do not do TLS handshakes and just forward things around. After the user types <a href="https://www.google.com" rel="nofollow" target="_blank">https://www.google.com</a> in their browser, it creates a TCP connection to us and then starts the TLS handshake. The first step of a TLS handshake is <code>ClientHello</code> discussed in <a href="https://tools.ietf.org/html/rfc5246#section-7.4.1.2" rel="nofollow" target="_blank">RFC5246 section 7.4.1.2.</a> (<a href="https://tools.ietf.org/html/rfc5246" rel="nofollow" target="_blank">RFC5246</a> is essentially TLS 1.2).</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/05.png" title="ClientHello sent from browser to proxy" alt="ClientHello sent from browser to proxy">
  <span class="caption-text">ClientHello sent from browser to proxy</span>
</span>


<p>Now I did not read the TLS 1.2 RFC completely and I doubt you need to either. As the proxy, we will see a <code>ClientHello</code> like this:</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/06.png" title="ClientHello as seen by proxy" alt="ClientHello as seen by proxy">
  <span class="caption-text">ClientHello as seen by proxy</span>
</span>


<p>But we are a proxy and we should know what it means. Tools should be able to do this for us. In this case I used Netmon and it decodes the <code>ClientHello</code> like this:</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/07.png" title="ClientHello deciphered" alt="ClientHello deciphered">
  <span class="caption-text">ClientHello deciphered</span>
</span>


<p>Now, we need to decide where to send this <code>ClientHello</code>. How can we discover the endpoint with this information?</p>

<p>Well, the answer is <strong>we can't</strong>.</p>

<h3 id="3-2-1-the-connect-request">3.2.1. The CONNECT Request</h3>

<p>In simple words, the browser needs to tell the proxy where to forward the requests and this should happen before the TLS handshake (and obviously after the TCP connection is established). That's where the <code>CONNECT</code> method comes into play.</p>

<p>The browser sends a request with the <code>CONNECT</code> method with the name of the domain to the proxy before the TLS handshake. This request contains the endpoint and the port in this format (<code>HOST:PORT</code>). Which called the <code>authority-form</code> format for request-target. We can see it in <a href="https://tools.ietf.org/html/rfc7230#section-5.3.3" rel="nofollow" target="_blank">RFC7230 section 5.3.3 - authority-form</a>.</p>

<blockquote>
<p>The authority-form of request-target is only used for CONNECT requests<br />
...<br />
a client MUST send only the target URI's authority component (excluding any userinfo and its &quot;@&quot; delimiter) as the request-target. For example,</p>

<p>CONNECT www.example.com:80 HTTP/1.1</p>
</blockquote>

<p>The <code>CONNECT</code> method is discussed in <a href="https://tools.ietf.org/html/rfc7231" rel="nofollow" target="_blank">RFC7231 - HTTP/1.1: Semantics and Content</a> in <a href="https://tools.ietf.org/html/rfc7231#section-4.3.6" rel="nofollow" target="_blank">section 4.3.6 - CONNECT</a>.</p>

<blockquote>
<p>The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed.</p>
</blockquote>

<p>The client instructions are as follows:</p>

<blockquote>
<p>A client sending a CONNECT request MUST send the authority form of request-target.<br />
...<br />
For example,</p>

<p>CONNECT server.example.com:80 HTTP/1.1<br />
Host: server.example.com:80</p>
</blockquote>

<p>The proxy should establish a connection to the destination and if successful should respond with a <code>2xx (Successful) response</code>. Before reading the RFC, I thought that the proxy sends the 2xx response immediately and then creates a connection to the destination. But I was wrong. The proxy only replies if it could connect to the endpoint, otherwise how could we tell the application that we could not establish a tunnel. The application starts the TLS handshake when it receives the 2xx response.</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/08.png" title="Forwarding proxy and HTTPs in action" alt="Forwarding proxy and HTTPs in action">
  <span class="caption-text">Forwarding proxy and HTTPs in action</span>
</span>


<ol>
<li>Browser creates a TCP connection to the forwarding proxy.</li>
<li>Browser sends the <code>CONNECT google.com:443</code> request to the proxy.</li>
<li>Proxy attempts to connect to <code>google.com:443</code>.</li>
<li>If successful, proxy responds with a <code>200 connection established</code>.</li>
<li>Now the browser knows that the proxy can contact the endpoint and starts the TLS handshake.</li>
<li>The forwarding proxy just passes requests until one side closes the connection, then it closes the other connection.</li>
</ol>

<h2 id="3-3-burp-and-https">3.3. Burp and HTTPs</h2>

<p>Things are similar with Burp (or any TLS terminating proxy). The only difference is that Burp MitMs the connection by doing a TLS handshake with the browser and thus will have the data in plaintext. By default Burp uses the endpoint name in the <code>CONNECT</code> request to auto-generate a certificate (signed by its root CA) and presents it to the client.</p>

<h3 id="3-3-1-correction-july-30th-2016">3.3.1. Correction - July 30th 2016</h3>

<p>The following picture is wrong. As our friends in the comments have noticed, there are two TCP connections from Burp to the server. My train of thought was that Burp first checks connectivity with the server before returning the 200 response and acts according to the RFC. And then opens a new connection to the server and does the sides of the connection.</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/09.png" title="This is wrong - see below" alt="This is wrong - see below">
  <span class="caption-text">This is wrong - see below</span>
</span>


<p>What actually happens is that Burp does not do the initial TCP connection to the endpoint after the <code>CONNECT</code> request and just responds with the 200 response. I went ahead and captured the traffic using Microsoft Message Analyzer (MMA). It enabled me to capture both local traffic from browser to Burp and from Burp to Google.com. Here's a picture of MMA that shows both TLS handshakes.</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/12.png" title="Both browser and Burp handshakes" alt="Both browser and Burp handshakes">
  <span class="caption-text">Both browser and Burp handshakes</span>
</span>


<p>The top part is the local traffic between browser and Burp and the bottom one is between Burp and Google.com. Packets are sorted chronologically. As you can see, Burp does not do a connectivity check when it gets the <code>CONNECT</code>. It proceeds with the TLS handshake and then only contacts Google.com after it  receives the first request (in this case the GET request). So the actual diagram should be this:</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/13.png" title="Burp and HTTPs in action - the correct one" alt="Burp and HTTPs in action - the correct one">
  <span class="caption-text">Burp and HTTPs in action - the correct one</span>
</span>


<h3 id="3-3-1-burp-s-invisible-mode">3.3.1. Burp's Invisible Mode</h3>

<p>I have talked about this probably <a href="#2-2-1-burp-s-invisible-proxying" title="Burp's Invisible Proxying" rel="nofollow" target="_blank">a hundred times</a>. We read that the RFC prevents proxies from using the <code>Host</code> header to re-route the traffic. Now if we have a client which uses HTTP but is not proxy-aware (or we have redirected its traffic to Burp without using proxy settings), we can enable Burp's invisible mode which uses the <code>Host</code> header to redirect traffic. This is one of the beauties of HTTP which makes is much easier to proxy than a custom protocol (e.g. a binary blob wrapped in TLS).</p>

<h1 id="4-cloudfront-and-server-name-indication">4. Cloudfront and Server Name Indication</h1>

<p>If you have captured <code>ClientHello</code> requests while playing around to see proxies in action (or just in general), you have noticed that your requests are not like the one I showed above. You can see the server's name in those <code>ClienHello</code>s. In fact, it is harder to catch a one without the server name. For my picture I had to navigate to a website by IP address.</p>

<p>What is that server name? It's a TLS extension called <code>Server Name Indication</code> or SNI. We can read about it in <a href="https://tools.ietf.org/html/rfc6066#page-6" rel="nofollow" target="_blank">RFC6066 section 3. Server Name Indication</a>:</p>

<blockquote>
<p>It may be desirable for clients to provide this information to facilitate secure connections to servers that host multiple 'virtual' servers at a single underlying network address.</p>
</blockquote>

<p>I am going to use my website as an example. <code>Parsiya.net</code> is a statically generated website using <a href="https://gohugo.io" rel="nofollow" target="_blank">Hugo</a>. It's hosted from an Amazon S3 bucket. S3 does not support TLS (or HTTPs if you want to call it) for statically hosted websites (it supports serving single files over TLS). In order to get TLS, I use Cloudfront in front of it. Cloudfront is Amazon's Content Distribution Network (CDN) and supports custom TLS certificates. If you use Cloudfront you can get a free TLS cert for your website. Cloudfront in this case is acting as the endpoint for many resources.</p>

<p>There should be a way for the browser to tell Cloudfront which endpoint it wants to connect so that Cloudfront can grab the correct TLS certificate and present it to the browser. This is enabled by SNI. A typical <code>ClientHello</code> for <code>parsiya.net</code> looks like the following (with decoded SNI):</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/10.png" title="ClientHello with SNI" alt="ClientHello with SNI">
  <span class="caption-text">ClientHello with SNI</span>
</span>


<p>Now we can see how Cloudfront works (simplified):</p>






<span class="caption-wrapper">
  <img class="caption" src="/images/2016/thickclient-6/11.png" title="SNI and Cloudfront" alt="SNI and Cloudfront">
  <span class="caption-text">SNI and Cloudfront</span>
</span>


<p>In this case Cloudfront is acting like a TLS terminating proxy. On one side it has HTTPs (browser &lt;-&gt; Cloudfront) and on the other side it has HTTP (Cloudfront &lt;-&gt; S3). But instead of using the <code>CONNECT</code> request we use SNI. This makes sense because Cloudfront is not set as a proxy for the browser.</p>

<h1 id="5-proxy-aware-clients">5. Proxy-Aware Clients</h1>

<p>Now I can talk about proxy-aware clients. We have already seen them and know what they do.</p>

<p>Proxy-aware clients know when they are connected to a proxy and if so, do the following:</p>

<ul>
<li>Use the <code>absolute-URI</code> in the requests sent to the proxy.</li>
<li>Send the <code>CONNECT</code> request to talk to the proxy about the endpoint before the TLS handshake.</li>
</ul>

<p>Usually proxy-aware clients have proxy settings or honor some OS specific ones (e.g. IE proxy settings). This signals that the browser is connected to a proxy and should act accordingly. Almost all browsers are proxy-aware.</p>

<h1 id="6-conclusion-and-future-plans">6. Conclusion and Future Plans</h1>

<p>Well that was all folks. Hopefully this is useful. Now we know how proxies work internally. Next time Burp messes up, capture the local traffic between the client and Burp and diagnose the problem. Pay attention to Burp's alert tab, usually TLS problems show up there too.</p>

<p>My plans for next part is to talk about traffic redirection techniques.</p>

<p>As usual if you have any questions/comments/feedback, you know where to find me.</p>

<!-- links -->
        </div>
        

<footer>
  <p class="meta">
    <span class="byline author vcard">Posted by <span class="fn">Parsia</span></span>
    
    <time>Jul 28, 2016</time>
    
      <span class="categories">
        Tags:
        
          <a class="category" href="http://localhost:1313/tags/proxying">Proxying</a>  <a class="category" href="http://localhost:1313/tags/burp">Burp</a>  <a class="category" href="http://localhost:1313/tags/tutorial">Tutorial</a>  
    
    </span>
  </p>

  

  <p class="meta">
    
        <a class="basic-alignment left" href="http://localhost:1313/blog/2016-07-14-gynvael-coldwind-garage4hackers-notes-from-march-2014/" title="Gynvael Coldwind - Garage4Hackers - Notes from March 2014">Gynvael Coldwind - Garage4Hackers - Notes from March 2014</a>
    

    
      <a class="basic-alignment right" href="http://localhost:1313/blog/2016-08-01-the-great-hiatus/" title="The Great Hiatus">The Great Hiatus</a>
    
  </p>
  
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "parsiya" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  
</footer>

      </article>
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    
      <h1>Who am I?</h1>
    

    <p>
      
        <p>I am Pitchaimuthu Muthaiya, a senior security engineer.</p>

<p>I write about application tamil words and roots of words.</p>

<p>Click on <a href="/about/">About Me!</a> to know more.</p>

      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      <a target="_blank" rel="noopener noreferrer" href="https://github.com/parsiya/" title="https://github.com/parsiya/"><i class="fa fa-github fa-3x"></i></a>
      
      
      <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/cryptogangsta/" title="https://twitter.com/cryptogangsta/"><i class="fa fa-twitter fa-3x"></i></a>
      
        <a target="_blank" rel="noopener noreferrer" href="https://keybase.io/parsiya/" title="https://keybase.io/parsiya/"><i class="fa fa-keybase fa-3x"></i></a> 
      
      <a target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com/in/parsiya" title="https://www.linkedin.com/in/parsiya"><i class="fa fa-linkedin fa-3x"></i></a>
      
      
      
      
      

    
    
    </li>
  </ul>

  

  
    
      <section class="odd">
        
          <h1>Collections</h1>
        
        
          <li>
            <a href="http://localhost:1313/categories/thick-client-proxying/" title="Thick Client Proxying" >Thick Client Proxying</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/writeup/" title="CTFs/Writeups" >CTFs/Writeups</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/attack-surface-analysis/" title="Attack Surface Analysis" >Attack Surface Analysis</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/bug-bounty/" title="Bug Bounty" >Bug Bounty</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/go/" title="Go/Golang" >Go/Golang</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/blockchain/" title="Blockchain" >Blockchain</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/burp-extension/" title="Burp Extension Development" >Burp Extension Development</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/automation/" title="Automation" >Automation</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/reverse-engineering/" title="Reverse Engineering" >Reverse Engineering</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/crypto/" title="Crypto(graphy)" >Crypto(graphy)</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/winappdbg/" title="WinAppDbg" >WinAppDbg</a>
          </li>
        
          <li>
            <a href="https://awsome.pw" title="AWSome.pw - S3 bucket squatting - my very legit branded vulnerability" >AWSome.pw - S3 bucket squatting - my very legit branded vulnerability</a>
          </li>
        
      </section>
    
  

  
  
  
</aside>

  </div>
</div>

    <footer role="contentinfo">
      <p>Copyright &copy; 2021 Parsia - <a href="http://localhost:1313/license/">License</a> -
        <span class="credit">Powered by <a target="_blank" href="https://gohugo.io" rel="noopener noreferrer">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/" rel="noopener noreferrer">Hugo-Octopress</a> theme.
      </p>
    </footer>

    
    



    
    
    

    
  </body>
</html>

