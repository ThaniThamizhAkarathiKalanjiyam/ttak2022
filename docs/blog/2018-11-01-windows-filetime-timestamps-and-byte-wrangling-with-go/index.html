<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
    
    
      <link href="/css/fonts.css" rel="stylesheet" type="text/css">
    
  

  
  <title>Windows Filetime Timestamps and Byte Wrangling with Go</title>

  
  
  <link rel="stylesheet" href="/css/hugo-octopress.css">

  
  

  
    <link rel="stylesheet" href="/css/fork-awesome.min.css">
  

  
  <link href="http://localhost:1313/favicon.png" rel="icon">

  
  

  <meta name="description" content="" />
  <meta name="keywords" content="[Parsia Hakimian Parsiya infosec information security]">
  <meta name="author" content="Parsia">

  
  <meta name="generator" content="Hugo 0.83.1" />

  
  

  
  
    

  
  
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:image:src" content="http://localhost:1313/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/filetime.png"/>
  
  
  <meta name="twitter:title" content="Windows Filetime Timestamps and Byte Wrangling with Go"/>
  <meta name="twitter:description" content="For a side project, I have to parse timestamps in a file. These timestamps are in the Windows Filetime format. This post documents what I have learned about them and how they can be converted to a Golang time.Time and then converted to any desirable format after that.

We will start by looking at endian-ness and use a real-world example to practice our newly acquired knowledge.

TL;DR: To convert a Windows Filetime to Go&#39;s time.Time:


Read 8 bytes in LittleEndian from the file.
Create a syscall.Filetime.


Assign the first 4 bytes to LowDateTime field and the other four to HighDateTime.

Convert the resulting Filetime to nanoseconds with Filetime.Nanoseconds().
Convert the resulting value to time.Time.


The code is at:


https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling
"/>
  
  <meta name="twitter:domain" content="parsiya.net"/>
  <meta name="twitter:creator" content="@CryptoGangsta"/>

  

  
  



</head>
<body>


<header role="banner">
<hgroup>
  
  <h1><a href="http://localhost:1313/">அஃக</a></h1>
    <h2>தமிழின் பெரிய சொற்தொகுப்பு</h2>
</hgroup></header>


<nav role="navigation">
<fieldset class="mobile-nav">
  
  <select onchange="location = this.value;">
    <option value="">Navigate…</option>
      
        <option value="http://localhost:1313/about/">» About Me!</option>
      
        <option value="http://localhost:1313/letters/">» எழுத்து</option>
      
  </select>
</fieldset>


<ul class="main-navigation">
  
  
    
      <li><a href="http://localhost:1313/about/" title="About Me!"  target="_blank"  rel="noopener noreferrer">About Me!</a></li>
    
  
    
      <li><a href="http://localhost:1313/letters/" title="எழுத்து"  target="_blank"  rel="noopener noreferrer">எழுத்து</a></li>
    
  
</ul>

<ul class="subscription">
  
    
        <a href="http://localhost:1313/index.xml" target="_blank" type="application/rss+xml" title="RSS" rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a>
    
  
</ul>


  <form action="https://www.google.com/search" method="get" target="_blank" rel="noopener noreferrer">
    <fieldset role="search">
      <input class="search" type="text" name="q" results="0" placeholder="Search"/>
      <input type="hidden" name="q" value="site:http://localhost:1313/" />
    </fieldset>
  </form>

</nav>


<div id="main">
  <div id="content">
    <div>
      <article class="hentry" role="article">

        
        

<header>
  <p class="meta">Nov 1, 2018
     - 7 minute read 
     - <a href="http://localhost:1313/blog/2018-11-01-windows-filetime-timestamps-and-byte-wrangling-with-go/#disqus_thread">Comments</a>

    
    
      - <a class="label" href="http://localhost:1313/categories/go/">Go </a>
    
  </p>
  <h1 class="entry-title">
     Windows Filetime Timestamps and Byte Wrangling with Go 
  </h1>
</header>


        <div class="entry-content">
          
          
          
            <nav id="TableOfContents">
<ul>
<li><a href="#endianness-with-useful-examples">Endianness with Useful Examples</a></li>
<li><a href="#binary-read">binary.Read</a>
<ul>
<li><a href="#reading-byte-or-byte">Reading []byte or [...]byte</a></li>
</ul></li>
<li><a href="#mild-lnk-reverse-engineering">Mild lnk Reverse Engineering</a></li>
<li><a href="#filetime">Filetime</a></li>
</ul>
</nav>
          
          <p>For a side project, I have to parse timestamps in a file. These timestamps are in the Windows Filetime format. This post documents what I have learned about them and how they can be converted to a Golang <a href="https://golang.org/pkg/time/#Time" rel="nofollow" target="_blank">time.Time</a> and then converted to any desirable format after that.</p>

<p>We will start by looking at endian-ness and use a real-world example to practice our newly acquired knowledge.</p>

<p><strong>TL;DR: To convert a Windows Filetime to Go's time.Time:</strong></p>

<ol>
<li>Read 8 bytes in LittleEndian from the file.</li>
<li>Create a <code>syscall.Filetime</code>.

<ul>
<li>Assign the first 4 bytes to <code>LowDateTime</code> field and the other four to <code>HighDateTime</code>.</li>
</ul></li>
<li>Convert the resulting Filetime to nanoseconds with <a href="https://godoc.org/golang.org/x/sys/windows#Filetime.Nanoseconds" rel="nofollow" target="_blank">Filetime.Nanoseconds()</a>.</li>
<li>Convert the resulting value to <a href="https://golang.org/pkg/time/#Time" rel="nofollow" target="_blank">time.Time</a>.</li>
</ol>

<p>The code is at:</p>

<ul>
<li><a href="https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling" rel="nofollow" target="_blank">https://github.com/parsiya/Parsia-Code/tree/master/filetime-bytewrangling</a></li>
</ul>

<h1 id="endianness-with-useful-examples">Endianness with Useful Examples</h1>

<p>You probably already know about endianness. It's how the bytes are ordered. Literals are almost always written in big-endian like <code>0xAABBCCDD</code>. In math, numbers are stored and read in big-endian (e.g. <code>1337</code>). In little-endian, they are stored with LSB being first. So the result is <code>DD CC BB AA</code> on disk. When reading from disk, we read four bytes and then reverse it.</p>

<p>Network protocols usually deal with the big-endian order. When sending data, we read and send the first byte first. When we look at the data on the wire, LSB is seen first and then the rest.</p>

<p>What infuriates me are the examples. Every tutorial uses only four bytes (like I did above). But what if we want to read a <code>dword</code> (a double-word is usually 8 bytes) from disk (little-endian). Do we read all bytes and reverse them? What about two <code>word</code>s?</p>

<p>Let's try to read these 8 bytes into a <code>uint64</code> <code>D0 E9 EE F2 15 15 C9 01</code>. Run <code>01-littleendian-uint64.go</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">package</span> main

<span style="color:#719e07">import</span> (
	<span style="color:#2aa198">&#34;encoding/binary&#34;</span>
	<span style="color:#2aa198">&#34;encoding/hex&#34;</span>
	<span style="color:#2aa198">&#34;fmt&#34;</span>
	<span style="color:#2aa198">&#34;strings&#34;</span>
)

<span style="color:#268bd2">func</span> <span style="color:#268bd2">main</span>() {
    <span style="color:#586e75">// Simulate 8 bytes BigEndian.
</span><span style="color:#586e75"></span>    cr, _ <span style="color:#719e07">:=</span> hex.<span style="color:#268bd2">DecodeString</span>(strings.<span style="color:#268bd2">Replace</span>(<span style="color:#2aa198">&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style="color:#2aa198">&#34; &#34;</span>, <span style="color:#2aa198">&#34;&#34;</span>, <span style="color:#719e07">-</span><span style="color:#2aa198">1</span>))
    <span style="color:#586e75">// Read them into a uint64
</span><span style="color:#586e75"></span>    u64 <span style="color:#719e07">:=</span> binary.LittleEndian.<span style="color:#268bd2">Uint64</span>(cr)
    <span style="color:#586e75">// Print the bytes
</span><span style="color:#586e75"></span>    fmt.<span style="color:#268bd2">Printf</span>(<span style="color:#2aa198">&#34;%016x&#34;</span>, u64)
    <span style="color:#586e75">// 01c91515f2eee9d0
</span><span style="color:#586e75"></span>}</code></pre></div>
<p>Using <code>BigEndian</code> would give us the order in the original string.</p>

<h1 id="binary-read">binary.Read</h1>

<p>When reading from a file, we are mostly dealing with an <code>io.Reader</code>. They are great for file parsing. We can read as we go and do not have to worry about keeping track of the offset. Another advantage is using <a href="https://golang.org/pkg/encoding/binary/#Read" rel="nofollow" target="_blank">binary.Read</a>. We can pass a data structure to it (as a pointer), it will detect the size and try to fill it. Run <code>02-littleendian-uint64-reader.go</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">package</span> main

<span style="color:#719e07">import</span> (
	<span style="color:#2aa198">&#34;bytes&#34;</span>
	<span style="color:#2aa198">&#34;encoding/binary&#34;</span>
	<span style="color:#2aa198">&#34;encoding/hex&#34;</span>
	<span style="color:#2aa198">&#34;fmt&#34;</span>
	<span style="color:#2aa198">&#34;strings&#34;</span>
)

<span style="color:#268bd2">func</span> <span style="color:#268bd2">main</span>() {
	<span style="color:#586e75">// Simulate 8 bytes BigEndian.
</span><span style="color:#586e75"></span>	cr, _ <span style="color:#719e07">:=</span> hex.<span style="color:#268bd2">DecodeString</span>(strings.<span style="color:#268bd2">Replace</span>(<span style="color:#2aa198">&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style="color:#2aa198">&#34; &#34;</span>, <span style="color:#2aa198">&#34;&#34;</span>, <span style="color:#719e07">-</span><span style="color:#2aa198">1</span>))
	<span style="color:#586e75">// Create an io.Reader from []byte for simulation.
</span><span style="color:#586e75"></span>	buf <span style="color:#719e07">:=</span> bytes.<span style="color:#268bd2">NewReader</span>(cr)
	<span style="color:#268bd2">var</span> u64 <span style="color:#dc322f">uint64</span>
	err <span style="color:#719e07">:=</span> binary.<span style="color:#268bd2">Read</span>(buf, binary.LittleEndian, <span style="color:#719e07">&amp;</span>u64)
	<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
		<span style="color:#b58900">panic</span>(err)
	}

    fmt.<span style="color:#268bd2">Printf</span>(<span style="color:#2aa198">&#34;%016x&#34;</span>, u64)
    <span style="color:#586e75">// 01c91515f2eee9d0
</span><span style="color:#586e75"></span>}</code></pre></div>
<p>But what if we want to read two little-endian <code>uint32</code>s? That is similar. Run <code>03-littlendian-two-uint32.go</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">package</span> main

<span style="color:#719e07">import</span> (
	<span style="color:#2aa198">&#34;bytes&#34;</span>
	<span style="color:#2aa198">&#34;encoding/binary&#34;</span>
	<span style="color:#2aa198">&#34;encoding/hex&#34;</span>
	<span style="color:#2aa198">&#34;fmt&#34;</span>
	<span style="color:#2aa198">&#34;strings&#34;</span>
)

<span style="color:#268bd2">func</span> <span style="color:#268bd2">main</span>() {
	<span style="color:#586e75">// Simulate 8 bytes BigEndian.
</span><span style="color:#586e75"></span>	cr, _ <span style="color:#719e07">:=</span> hex.<span style="color:#268bd2">DecodeString</span>(strings.<span style="color:#268bd2">Replace</span>(<span style="color:#2aa198">&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style="color:#2aa198">&#34; &#34;</span>, <span style="color:#2aa198">&#34;&#34;</span>, <span style="color:#719e07">-</span><span style="color:#2aa198">1</span>))
	<span style="color:#586e75">// Create an io.Reader from []byte.
</span><span style="color:#586e75"></span>	buf <span style="color:#719e07">:=</span> bytes.<span style="color:#268bd2">NewReader</span>(cr)
	<span style="color:#268bd2">var</span> u32One, u32Two <span style="color:#dc322f">uint32</span>
	err <span style="color:#719e07">:=</span> binary.<span style="color:#268bd2">Read</span>(buf, binary.LittleEndian, <span style="color:#719e07">&amp;</span>u32One)
	<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
		<span style="color:#b58900">panic</span>(err)
	}
	err = binary.<span style="color:#268bd2">Read</span>(buf, binary.LittleEndian, <span style="color:#719e07">&amp;</span>u32Two)
	<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
		<span style="color:#b58900">panic</span>(err)
	}

	fmt.<span style="color:#268bd2">Printf</span>(<span style="color:#2aa198">&#34;u32-1: %08x\n&#34;</span>, u32One) <span style="color:#586e75">// u32-1: f2eee9d0
</span><span style="color:#586e75"></span>	fmt.<span style="color:#268bd2">Printf</span>(<span style="color:#2aa198">&#34;u32-1: %08x\n&#34;</span>, u32Two) <span style="color:#586e75">// u32-1: 01c91515
</span><span style="color:#586e75"></span>}</code></pre></div>
<p>Both approaches pretty much give us the same results.</p>

<h2 id="reading-byte-or-byte">Reading []byte or [...]byte</h2>

<p>We can also fill <code>[]byte</code> from <code>io.Reader</code> with <code>binary.Read</code>. In these cases, we need to create a <code>[]byte</code> of a specific length and read those many bytes. Let's get the entire 72 bytes from the original example <code>04-read-byte-slice.go</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">package</span> main

<span style="color:#719e07">import</span> (
	<span style="color:#2aa198">&#34;bytes&#34;</span>
	<span style="color:#2aa198">&#34;encoding/binary&#34;</span>
	<span style="color:#2aa198">&#34;encoding/hex&#34;</span>
	<span style="color:#2aa198">&#34;fmt&#34;</span>
)

<span style="color:#268bd2">func</span> <span style="color:#268bd2">main</span>() {
	cr, _ <span style="color:#719e07">:=</span> hex.<span style="color:#268bd2">DecodeString</span>(<span style="color:#2aa198">&#34;4C0000000114020000000000C000000000000046&#34;</span> <span style="color:#719e07">+</span>
		<span style="color:#2aa198">&#34;9B00080020000000D0E9EEF21515C901D0E9EEF21515C901D0E9EEF21515C90100&#34;</span> <span style="color:#719e07">+</span>
		<span style="color:#2aa198">&#34;0000000000000001000000000000000000000000000000&#34;</span>)
	<span style="color:#586e75">// Create an io.Reader from []byte.
</span><span style="color:#586e75"></span>	buf <span style="color:#719e07">:=</span> bytes.<span style="color:#268bd2">NewReader</span>(cr)

	headerLittleEndian <span style="color:#719e07">:=</span> <span style="color:#b58900">make</span>([]<span style="color:#dc322f">byte</span>, <span style="color:#2aa198">72</span>)
	err <span style="color:#719e07">:=</span> binary.<span style="color:#268bd2">Read</span>(buf, binary.LittleEndian, <span style="color:#719e07">&amp;</span>headerLittleEndian)
	<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
		<span style="color:#b58900">panic</span>(err)
	}
	fmt.<span style="color:#268bd2">Println</span>(<span style="color:#2aa198">&#34;headerLittleEndian&#34;</span>)
	fmt.<span style="color:#268bd2">Println</span>(hex.<span style="color:#268bd2">Dump</span>(headerLittleEndian))

	<span style="color:#586e75">// Reset the reader.
</span><span style="color:#586e75"></span>	buf = bytes.<span style="color:#268bd2">NewReader</span>(cr)
	headerBigEndian <span style="color:#719e07">:=</span> <span style="color:#b58900">make</span>([]<span style="color:#dc322f">byte</span>, <span style="color:#2aa198">72</span>)
	err = binary.<span style="color:#268bd2">Read</span>(buf, binary.BigEndian, <span style="color:#719e07">&amp;</span>headerBigEndian)
	<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
		<span style="color:#b58900">panic</span>(err)
	}
	fmt.<span style="color:#268bd2">Println</span>(<span style="color:#2aa198">&#34;headerBigEndian&#34;</span>)
	fmt.<span style="color:#268bd2">Println</span>(hex.<span style="color:#268bd2">Dump</span>(headerBigEndian))
}</code></pre></div>
<p>And the result is the same in both cases.</p>
<pre><code>headerLittleEndian
00000000  4c 00 00 00 01 14 02 00  00 00 00 00 c0 00 00 00  |L...............|
00000010  00 00 00 46 9b 00 08 00  20 00 00 00 d0 e9 ee f2  |...F.... .......|
00000020  15 15 c9 01 d0 e9 ee f2  15 15 c9 01 d0 e9 ee f2  |................|
00000030  15 15 c9 01 00 00 00 00  00 00 00 00 01 00 00 00  |................|
00000040  00 00 00 00 00 00 00 00                           |........|

headerBigEndian
00000000  4c 00 00 00 01 14 02 00  00 00 00 00 c0 00 00 00  |L...............|
00000010  00 00 00 46 9b 00 08 00  20 00 00 00 d0 e9 ee f2  |...F.... .......|
00000020  15 15 c9 01 d0 e9 ee f2  15 15 c9 01 d0 e9 ee f2  |................|
00000030  15 15 c9 01 00 00 00 00  00 00 00 00 01 00 00 00  |................|
00000040  00 00 00 00 00 00 00 00                           |........|</code></pre>
<p><strong>If you are reading []byte or byte arrays, the order doesn't really matter. You get the original order of bytes.</strong></p>

<p>That was quite the detour, but now we know how ro read bytes in Go.</p>

<h1 id="mild-lnk-reverse-engineering">Mild lnk Reverse Engineering</h1>

<p>We are going to use a Windows Shortcut or <code>lnk</code> file for practice. Luckily, MSDN has an <a href="https://msdn.microsoft.com/en-us/library/dd871375.aspx" rel="nofollow" target="_blank">example</a>. We are going to only need the file header or the first <code>72</code> (or <code>0x4C</code>) bytes. Here's a hexdump:</p>
<pre><code>00000000  4C 00 00 00 01 14 02 00 00 00 00 00 C0 00 00 00  |L...........À...|
00000010  00 00 00 46 9B 00 08 00 20 00 00 00 D0 E9 EE F2  |...F.... ...Ðéîò|
00000020  15 15 C9 01 D0 E9 EE F2 15 15 C9 01 D0 E9 EE F2  |..É.Ðéîò..É.Ðéîò|
00000030  15 15 C9 01 00 00 00 00 00 00 00 00 01 00 00 00  |..É.............|
00000040  00 00 00 00 00 00 00 00 00 00 00 00              |............|</code></pre>
<p>MSDN has the <a href="https://msdn.microsoft.com/en-us/library/dd871305.aspx" rel="nofollow" target="_blank">MS-SHLLINK</a>. Open the revision 5.0 (latest at the time of writing) file to see the format. The example page also contains a break down of all fields.</p>

<p>There are three timestamps. Each one is eight bytes and is stored in little-endian order:</p>

<ul>
<li><code>CreationTime</code> at offset <code>0x1C</code>: <code>D0 E9 EE F2 15 15 C9 01</code></li>
<li><code>AccessTime</code> at offset <code>0x24</code>: <code>D0 E9 EE F2 15 15 C9 01</code></li>
<li><code>WriteTime</code> at offset <code>0x2C</code>: <code>D0 E9 EE F2 15 15 C9 01</code></li>
</ul>

<h1 id="filetime">Filetime</h1>

<p>According to the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284(v=vs.85).aspx" rel="nofollow" target="_blank">FILETIME structure</a>, it's &quot;a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).&quot; Oh boy!</p>

<p>We need to convert it to to Unix nano, which is the number of nanoseconds elapsed since January 1, 1970, 00:00:00 (UTC). To convert these, we can either do things by hand (multiply the Windows timestamp by 100 and then subtract the number of nanoseconds between epoch times) or just let someone else do the calculation for us. Fortunately, I found a type in Go in two places that point to one location:</p>

<ul>
<li><a href="https://golang.org/pkg/syscall/?GOOS=windows&amp;GOARCH=amd64#Filetime" rel="nofollow" target="_blank">syscall.Filetime</a></li>

<li><p><a href="https://godoc.org/golang.org/x/sys/windows#Filetime" rel="nofollow" target="_blank">golang.org/x/sys/windows.Filetime</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#268bd2">type</span> Filetime <span style="color:#268bd2">struct</span> {
	LowDateTime  <span style="color:#dc322f">uint32</span>
	HighDateTime <span style="color:#dc322f">uint32</span>
}</code></pre></div></li>
</ul>

<p>To convert a Windows Filetime to Go's time.Time:</p>

<ol>
<li>Read 8 bytes in LittleEndian from the file.</li>
<li>Create a <code>syscall.Filetime</code>.

<ol>
<li>Assign the first 4 bytes to <code>LowDateTime</code> field and the other to <code>HighDateTime</code>.</li>
</ol></li>
<li>Convert the resulting Filetime to nanoseconds with <a href="https://godoc.org/golang.org/x/sys/windows#Filetime.Nanoseconds" rel="nofollow" target="_blank">Filetime.Nanoseconds()</a>.</li>
<li>Convert the resulting value to time.Time.</li>
</ol>

<p>Let's create a function:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// toTime converts an 8-byte Windows Filetime to time.Time.
</span><span style="color:#586e75"></span><span style="color:#268bd2">func</span> <span style="color:#268bd2">toTime</span>(t [<span style="color:#2aa198">8</span>]<span style="color:#dc322f">byte</span>) time.Time {
	ft <span style="color:#719e07">:=</span> <span style="color:#719e07">&amp;</span>syscall.Filetime{
		LowDateTime:  binary.LittleEndian.<span style="color:#268bd2">Uint32</span>(t[:<span style="color:#2aa198">4</span>]),
		HighDateTime: binary.LittleEndian.<span style="color:#268bd2">Uint32</span>(t[<span style="color:#2aa198">4</span>:]),
	}
	<span style="color:#719e07">return</span> time.<span style="color:#268bd2">Unix</span>(<span style="color:#2aa198">0</span>, ft.<span style="color:#268bd2">Nanoseconds</span>())
}</code></pre></div>
<p>We are passing an 8-byte array (we could modify it to be a <code>[]byte</code> but that would add range checks, error handling, and panics). The byte array is most likely big-endian (because we read it directly from the reader), so we are reading each <code>uint32</code> in little-endian order. Then we populate <code>Filetime</code> and finally convert it to <code>time.Time</code>. Now we can do whatever we want with this.</p>

<p>Let's run this function on our timestamp (all three are the same in the MSDN example). Run <code>05-parse-timestamp.go</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">package</span> main

<span style="color:#719e07">import</span> (
	<span style="color:#2aa198">&#34;bytes&#34;</span>
	<span style="color:#2aa198">&#34;encoding/binary&#34;</span>
	<span style="color:#2aa198">&#34;encoding/hex&#34;</span>
	<span style="color:#2aa198">&#34;fmt&#34;</span>
	<span style="color:#2aa198">&#34;strings&#34;</span>
	<span style="color:#2aa198">&#34;syscall&#34;</span>
	<span style="color:#2aa198">&#34;time&#34;</span>
)

<span style="color:#268bd2">func</span> <span style="color:#268bd2">main</span>() {
	cr, _ <span style="color:#719e07">:=</span> hex.<span style="color:#268bd2">DecodeString</span>(strings.<span style="color:#268bd2">Replace</span>(<span style="color:#2aa198">&#34;D0 E9 EE F2 15 15 C9 01&#34;</span>, <span style="color:#2aa198">&#34; &#34;</span>, <span style="color:#2aa198">&#34;&#34;</span>, <span style="color:#719e07">-</span><span style="color:#2aa198">1</span>))
	buf <span style="color:#719e07">:=</span> bytes.<span style="color:#268bd2">NewReader</span>(cr)
	<span style="color:#268bd2">var</span> timestamp [<span style="color:#2aa198">8</span>]<span style="color:#dc322f">byte</span>
	err <span style="color:#719e07">:=</span> binary.<span style="color:#268bd2">Read</span>(buf, binary.LittleEndian, <span style="color:#719e07">&amp;</span>timestamp)
	<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
		<span style="color:#b58900">panic</span>(err)
	}

	t <span style="color:#719e07">:=</span> <span style="color:#268bd2">toTime</span>(timestamp)
	fmt.<span style="color:#268bd2">Println</span>(t)
	fmt.<span style="color:#268bd2">Println</span>(t.<span style="color:#268bd2">UTC</span>())
}

<span style="color:#586e75">// toTime converts an 8-byte Windows Filetime to time.Time.
</span><span style="color:#586e75"></span><span style="color:#268bd2">func</span> <span style="color:#268bd2">toTime</span>(t [<span style="color:#2aa198">8</span>]<span style="color:#dc322f">byte</span>) time.Time {
	ft <span style="color:#719e07">:=</span> <span style="color:#719e07">&amp;</span>syscall.Filetime{
		LowDateTime:  binary.LittleEndian.<span style="color:#268bd2">Uint32</span>(t[:<span style="color:#2aa198">4</span>]),
		HighDateTime: binary.LittleEndian.<span style="color:#268bd2">Uint32</span>(t[<span style="color:#2aa198">4</span>:]),
	}
	<span style="color:#719e07">return</span> time.<span style="color:#268bd2">Unix</span>(<span style="color:#2aa198">0</span>, ft.<span style="color:#268bd2">Nanoseconds</span>())
}</code></pre></div>
<p>Which is the same as the MSDN example:</p>
<pre><code>2008-09-12 16:27:17.101 -0400 EDT
2008-09-12 20:27:17.101 +0000 UTC</code></pre>
<!-- Links -->
        </div>
        

<footer>
  <p class="meta">
    <span class="byline author vcard">Posted by <span class="fn">Parsia</span></span>
    
    <time>Nov 1, 2018</time>
    
      <span class="categories">
        Tags:
        
          <a class="category" href="http://localhost:1313/tags/filetime">filetime</a>  
    
    </span>
  </p>

  

  <p class="meta">
    
        <a class="basic-alignment left" href="http://localhost:1313/blog/2018-10-28-blackfridays-parser-and-generating-graphs-with-gographviz/" title="Blackfriday&#39;s Parser and Generating graphs with gographviz">Blackfriday&#39;s Parser and Generating graphs with gographviz</a>
    

    
      <a class="basic-alignment right" href="http://localhost:1313/blog/2018-11-10-filepath.ext-notes/" title="filepath.Ext Notes">filepath.Ext Notes</a>
    
  </p>
  
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "parsiya" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  
</footer>

      </article>
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    
      <h1>Who am I?</h1>
    

    <p>
      
        <p>I am Pitchaimuthu Muthaiya, a senior security engineer.</p>

<p>I write about application tamil words and roots of words.</p>

<p>Click on <a href="/about/">About Me!</a> to know more.</p>

      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      <a target="_blank" rel="noopener noreferrer" href="https://github.com/parsiya/" title="https://github.com/parsiya/"><i class="fa fa-github fa-3x"></i></a>
      
      
      <a target="_blank" rel="noopener noreferrer" href="https://twitter.com/cryptogangsta/" title="https://twitter.com/cryptogangsta/"><i class="fa fa-twitter fa-3x"></i></a>
      
        <a target="_blank" rel="noopener noreferrer" href="https://keybase.io/parsiya/" title="https://keybase.io/parsiya/"><i class="fa fa-keybase fa-3x"></i></a> 
      
      <a target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com/in/parsiya" title="https://www.linkedin.com/in/parsiya"><i class="fa fa-linkedin fa-3x"></i></a>
      
      
      
      
      

    
    
    </li>
  </ul>

  

  
    
      <section class="odd">
        
          <h1>Collections</h1>
        
        
          <li>
            <a href="http://localhost:1313/categories/thick-client-proxying/" title="Thick Client Proxying" >Thick Client Proxying</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/writeup/" title="CTFs/Writeups" >CTFs/Writeups</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/attack-surface-analysis/" title="Attack Surface Analysis" >Attack Surface Analysis</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/bug-bounty/" title="Bug Bounty" >Bug Bounty</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/go/" title="Go/Golang" >Go/Golang</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/blockchain/" title="Blockchain" >Blockchain</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/burp-extension/" title="Burp Extension Development" >Burp Extension Development</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/automation/" title="Automation" >Automation</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/reverse-engineering/" title="Reverse Engineering" >Reverse Engineering</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/crypto/" title="Crypto(graphy)" >Crypto(graphy)</a>
          </li>
        
          <li>
            <a href="http://localhost:1313/categories/winappdbg/" title="WinAppDbg" >WinAppDbg</a>
          </li>
        
          <li>
            <a href="https://awsome.pw" title="AWSome.pw - S3 bucket squatting - my very legit branded vulnerability" >AWSome.pw - S3 bucket squatting - my very legit branded vulnerability</a>
          </li>
        
      </section>
    
  

  
  
  
</aside>

  </div>
</div>

    <footer role="contentinfo">
      <p>Copyright &copy; 2021 Parsia - <a href="http://localhost:1313/license/">License</a> -
        <span class="credit">Powered by <a target="_blank" href="https://gohugo.io" rel="noopener noreferrer">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/" rel="noopener noreferrer">Hugo-Octopress</a> theme.
      </p>
    </footer>

    
    



    
    
    

    
  </body>
</html>

